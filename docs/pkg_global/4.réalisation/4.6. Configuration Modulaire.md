---
chapitre: true
package: pkg_global
order: 46
---

## **4.6. Configuration de Laravel pour une utilisation modulaire**

L’objectif de la configuration modulaire est de structurer l’application Laravel en modules indépendants. Chaque module est isolé, ce qui facilite la gestion, la maintenance et l’évolution du projet.



### **1. Comprendre la modularité dans Laravel**
- **Approche monolithique modulaire** : Plutôt que de gérer toute l’application dans les répertoires par défaut (`app`, `resources`, etc.), chaque module est organisé en packages.
- **Structure suggérée** :
  ```
  /modules
    /Core
    /PkgBlog
    /PkgBlogPublic
    /PkgProfile
  ```



### **2. Étapes de configuration**

#### **2.1. Création du répertoire des modules**
- Dans la racine de votre projet, créez un dossier `modules` :
  ```bash
  mkdir modules
  ```

#### **2.2. Chargement automatique des modules et des helpers**

Nous avons organiser les helpers dans deux fichier : 

- ``app/helpers/ModulesHelpers.php``
- ``app/helpers/TranslationHelper.php``

- Ajoutez un autoloader dans `composer.json` :
  ```json
  "autoload": {
        "psr-4": {
            "App\\": "app/",
            "Modules\\": "modules/",
            "Database\\Factories\\": "database/factories/",
            "Database\\Seeders\\": "database/seeders/"
        } ,
        "files": [
            "app/helpers/ModulesHelpers.php",
            "app/helpers/TranslationHelper.php"
        ]   
    }
  ```
- Mettez à jour Composer :
  ```bash
  composer dump-autoload
  ```

### Chargement des provider des modules 

Charger dynamiquement tous les ServiceProviders des modules.

````php
<?php

namespace App\Providers;

use Illuminate\Pagination\Paginator;
use Illuminate\Support\ServiceProvider;

class AppServiceProvider extends ServiceProvider
{
    /**
     * Enregistrement des services nécessaires à l'application.
     */
    public function register(): void
    {
        // Charger dynamiquement tous les ServiceProviders des modules.
        $this->loadModuleServiceProviders();
    }

    /**
     * Démarrage de divers services de l'application.
     */
    public function boot(): void
    {
        // Configuration de la pagination pour utiliser le style Bootstrap.
        Paginator::useBootstrap();
    }

    /**
     * Charger dynamiquement les ServiceProviders depuis les modules.
     *
     * @return void
     */
    protected function loadModuleServiceProviders()
    {
        // Chemin vers le dossier contenant les modules.
        $moduleProvidersPath = base_path('modules');

        // Récupérer tous les fichiers correspondant à un ServiceProvider dans les modules.
        $providerFiles = glob($moduleProvidersPath . '/*/App/Providers/*ServiceProvider.php');

        foreach ($providerFiles as $providerFile) {
            // Récupérer le nom complet de la classe du ServiceProvider.
            $providerClass = $this->getProviderClass($providerFile);

            // Vérifier si la classe existe avant de l'enregistrer.
            if (class_exists($providerClass)) {
                $this->app->register($providerClass);
            }
        }
    }

    /**
     * Récupérer la classe du ServiceProvider à partir du fichier PHP.
     *
     * @param string $file
     * @return string
     */
    protected function getProviderClass(string $file): string
    {
        
        // Transformer le chemin de fichier en nom de classe PHP avec namespace
        $relativePath = str_replace(base_path(), '', $file); // Obtenir le chemin relatif
       
        $relativePath = str_replace('/', '\\', $relativePath); // Convertir les / en \
        $relativePath = trim($relativePath, '\\'); // Supprimer les \ en trop
        $relativePath = str_replace('.php', '', $relativePath); 
        // Remplacer uniquement "module" par "Module" au début du chemin
       
        if (substr($relativePath, 0, 7) === 'modules') {
             $relativePath = 'Modules' . substr($relativePath, 7);
        }
    
        // Exemple : Modules\PkgArticles\App\Providers\PkgArticlesServiceProvider
        return  $relativePath;
    }
}

````


#### **2.3. Configuration de chaque module**
- Chaque module aura sa propre structure :
  ```
  /modules
    /PkgBlog
      /App
      /Controllers
      /Models
      /Repositories
      /resources
      /Database
      /Routes
  ```

### Exécution des Seeder de façon dynamique 


````php
<?php

namespace Database\Seeders;


// use Illuminate\Database\Console\Seeds\WithoutModelEvents;

use Illuminate\Database\Seeder;
use Illuminate\Support\Facades\File;
use Illuminate\Support\Str;

use Database\Seeders\{
    UserSeeder
};
use Database\Seeders\Autorisation\RoleSeeder;


class DatabaseSeeder extends Seeder
{
    public function run(): void
    {
        $this->call(RoleSeeder::class);
        $this->call(UserSeeder::class);
        $this->run_modules_seeders();
    }

    public function run_modules_seeders():void{

        $this->command->info('Parcourir tous les modules et exécuter leurs seeders');

        // Récupérer tous les dossiers de modules
        $modulesPath = base_path('modules');
        $modules = File::directories($modulesPath);
         
        // Parcourir tous les modules et exécuter leurs seeders
        foreach ($modules as $module) {

            if(basename($module) == "Core") { continue;}
            
            // Trouver le seeder principal du module en recherchant le fichier de seeder
            $seederFile = $module . '/Database/Seeders/' . Str::studly(basename($module)) . 'Seeder.php';

            // Vérifier si le fichier de seeder existe
            if (File::exists($seederFile)) {

                // Appeler le seeder du module
                $seederClass = 'Modules\\' . Str::studly(basename($module)) . '\\Database\\Seeders\\' . Str::studly(basename($module)) . 'Seeder';
                $this->command->info('Appeler le seeder :' . $seederClass);
                $this->call($seederClass);
            }
        }
    }
}

````

### Exemple de configuration d'un module par ServiceProvider

````php
namespace Modules\PkgBlog\App\Providers;

use Illuminate\Support\ServiceProvider;
use Illuminate\Support\Facades\Route;
use Illuminate\Support\Facades\File;

class PkgBlogServiceProvider extends ServiceProvider
{
    /**
     * Enregistrer les services dans l'application.
     *
     * @return void
     */
    public function register()
    {
        // Vous pouvez enregistrer les services spécifiques au module ici.
    }

    /**
     * Effectuer les opérations de démarrage pour le module.
     *
     * @return void
     */
    public function boot()
    {
        // Charger les migrations
        $this->loadMigrationsFrom(__DIR__ . '/../../database/migrations');

        // Charger les fichiers de routes du module
        $routeFiles = File::allFiles(__DIR__ . '/../../Routes');
        foreach ($routeFiles as $routeFile) {
            $this->loadRouteFile($routeFile);
        }

        // Charger les vues du module
        $this->loadViewsFrom(__DIR__ . '/../../resources/views', 'PkgBlog');

        // Charger les fichiers de traduction
        $this->loadTranslationsFrom(
            __DIR__ . '/../../resources/lang',
            'PkgBlog'
        );
    }

    /**
     * Charger un fichier de routes.
     *
     * @param \SplFileInfo $file
     */
    protected function loadRouteFile($file)
    {
        $filePath = $file->getPathname();
        $middleware = $this->getMiddleware($filePath);

        Route::middleware($middleware)->group(function () use ($filePath) {
            require $filePath;
        });
    }

    /**
     * Obtenir les middlewares en fonction du fichier de routes.
     *
     * @param string $filePath
     * @return array
     */
    protected function getMiddleware($filePath)
    {
        // Ajouter une logique pour déterminer les middlewares si nécessaire.
        return ['web'];
    }
}

````


### **Résumé**
Cette configuration permet de structurer une application Laravel en modules. Chaque module est autonome et peut contenir ses propres routes, contrôleurs, modèles, vues, et migrations. Cette approche modulaire facilite la collaboration entre équipes et améliore la maintenabilité du code.